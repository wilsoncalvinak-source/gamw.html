<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Starfighter: Overdrive</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff00;
            --neon-red: #ff3333;
            --neon-yellow: #ffff00;
            --bg-color: #050510;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: white;
            font-family: 'Orbitron', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            background: radial-gradient(circle at center, #0a0a20 0%, #000000 100%);
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            text-shadow: 0 0 10px var(--neon-blue);
        }

        .hud-bottom {
            padding: 20px;
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .stat-box {
            background: rgba(0, 20, 40, 0.7);
            border: 1px solid var(--neon-blue);
            padding: 10px 20px;
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
        }

        .score-display { font-size: 24px; color: var(--neon-yellow); }
        .wave-display { font-size: 18px; color: var(--neon-pink); }
        .hp-bar-container {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid white;
            position: relative;
            transform: skewX(-20deg);
        }
        .hp-bar-fill {
            width: 100%;
            height: 100%;
            background: var(--neon-green);
            transition: width 0.2s;
            box-shadow: 0 0 10px var(--neon-green);
        }

        .overdrive-bar-container {
            width: 200px;
            height: 10px;
            background: #333;
            border: 1px solid white;
            margin-top: 5px;
            transform: skewX(-20deg);
        }
        .overdrive-bar-fill {
            width: 0%;
            height: 100%;
            background: var(--neon-yellow);
            transition: width 0.1s;
        }

        /* Menus */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .menu-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        h1 {
            font-size: 64px;
            margin: 0 0 20px 0;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 4px;
            filter: drop-shadow(0 0 10px rgba(255,0,255,0.5));
            text-align: center;
        }

        .btn {
            background: transparent;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            padding: 15px 40px;
            border: 2px solid var(--neon-blue);
            margin: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 20px var(--neon-blue);
            transform: scale(1.05);
        }

        /* Shop Grid */
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
            max-width: 800px;
        }

        .shop-item {
            background: rgba(0,0,0,0.6);
            border: 1px solid #444;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: 0.2s;
        }

        .shop-item:hover:not(.disabled) {
            border-color: var(--neon-green);
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 255, 0, 0.2);
        }

        .shop-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .shop-item h3 { margin: 5px 0; font-size: 16px; color: var(--neon-blue); }
        .shop-item p { font-size: 12px; color: #aaa; text-align: center; margin: 5px 0; }
        .shop-item .cost { color: var(--neon-yellow); font-weight: bold; }

        /* Notification */
        #notification-area {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        .toast {
            display: inline-block;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--neon-blue);
            padding: 10px 20px;
            color: var(--neon-blue);
            font-size: 20px;
            animation: fadeUp 2s forwards;
            margin-bottom: 10px;
        }

        @keyframes fadeUp {
            0% { opacity: 0; transform: translateY(20px); }
            10% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* Scanlines */
        .scanlines {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            z-index: 100;
            opacity: 0.15;
        }
        
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>

    <!-- Main Menu -->
    <div id="main-menu" class="menu-overlay active">
        <h1>Neon Starfighter<br>Overdrive</h1>
        <p style="color: #aaa; margin-bottom: 30px;">WASD to Move • Mouse to Aim/Shoot • Space for Special</p>
        <button class="btn" onclick="Game.start()">Initialize System</button>
    </div>

    <!-- Pause / Shop Menu -->
    <div id="shop-menu" class="menu-overlay">
        <h1>System Upgrades</h1>
        <div class="shop-grid" id="shop-grid">
            <!-- Populated via JS -->
        </div>
        <div style="text-align: center; margin-bottom: 20px;">
            Current Score (Credits): <span id="shop-credits" style="color: var(--neon-yellow)">0</span>
        </div>
        <button class="btn" onclick="Game.resume()">Resume Mission</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-menu" class="menu-overlay">
        <h1 style="color: var(--neon-red)">CRITICAL FAILURE</h1>
        <p>Final Score: <span id="final-score" style="color: var(--neon-yellow)">0</span></p>
        <p>Waves Survived: <span id="final-wave" style="color: var(--neon-blue)">0</span></p>
        <button class="btn" onclick="Game.restart()">Reboot System</button>
    </div>

    <!-- HUD -->
    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-box">SCORE: <span class="score-display" id="hud-score">0</span></div>
            <div class="stat-box">WAVE: <span class="wave-display" id="hud-wave">1</span></div>
        </div>
        <div id="notification-area"></div>
        <div class="hud-bottom">
            <div>
                <div style="margin-bottom:5px; font-size: 12px; color: #aaa;">HULL INTEGRITY</div>
                <div class="hp-bar-container">
                    <div class="hp-bar-fill" id="hud-hp"></div>
                </div>
                <div class="overdrive-bar-container">
                    <div class="overdrive-bar-fill" id="hud-overdrive"></div>
                </div>
                <div style="font-size: 10px; color: var(--neon-yellow); text-align: right;">OVERDRIVE</div>
            </div>
            <div class="stat-box" style="font-size: 12px;">
                FPS: <span id="hud-fps">60</span>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * AUDIO ENGINE
 * Synthesizes sounds in real-time using Web Audio API.
 * No external assets required.
 */
class AudioController {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; // Global volume
        this.masterGain.connect(this.ctx.destination);
        this.enabled = true;
    }

    playTone(freq, type, duration, vol = 1, slide = 0) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if (slide !== 0) {
            osc.frequency.exponentialRampToValueAtTime(freq + slide, this.ctx.currentTime + duration);
        }

        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playNoise(duration, vol = 1) {
        if (!this.enabled) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        // Filter for explosion sound
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        noise.start();
    }

    // SFX Presets
    shoot() { this.playTone(400, 'square', 0.1, 0.3, -200); }
    enemyHit() { this.playTone(200, 'sawtooth', 0.1, 0.2, -100); }
    playerHit() { this.playNoise(0.5, 0.8); this.playTone(100, 'sawtooth', 0.5, 0.5, -50); }
    explosion() { this.playNoise(0.4, 0.6); }
    powerup() { this.playTone(600, 'sine', 0.3, 0.4, 600); }
    overdrive() { 
        this.playTone(100, 'square', 1.0, 0.5, 800); 
        setTimeout(() => this.playNoise(1.0, 0.8), 200);
    }
}

/**
 * MATH & UTILS
 */
const Utils = {
    rand: (min, max) => Math.random() * (max - min) + min,
    lerp: (a, b, t) => a + (b - a) * t,
    clamp: (val, min, max) => Math.min(Math.max(val, min), max),
    dist: (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1),
    checkCircleCol: (c1, c2) => Utils.dist(c1.x, c1.y, c2.x, c2.y) < c1.radius + c2.radius,
    hexToRgb: (hex) => {
        const bigint = parseInt(hex.replace('#',''), 16);
        return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
    }
};

/**
 * PARTICLE SYSTEM
 * Handles thousands of visual effects efficiently.
 */
class Particle {
    constructor(x, y, color, speed, angle, life, size, decay = true) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = life;
        this.maxLife = life;
        this.size = size;
        this.decay = decay;
        this.alpha = 1;
        this.drag = 0.95;
    }

    update(dt) {
        this.x += this.vx * dt * 60;
        this.y += this.vy * dt * 60;
        this.vx *= this.drag;
        this.vy *= this.drag;
        
        if (this.decay) {
            this.life -= dt;
            this.alpha = this.life / this.maxLife;
        } else {
            // Blinking or permanent effects
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class ParticleSystem {
    constructor() {
        this.particles = [];
    }

    createExplosion(x, y, color, count = 20) {
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Utils.rand(2, 8);
            const life = Utils.rand(0.5, 1.2);
            const size = Utils.rand(1, 4);
            this.particles.push(new Particle(x, y, color, speed, angle, life, size));
        }
    }

    createThrust(x, y, angle, color) {
        const spread = 0.3;
        const a = angle + Math.PI + Utils.rand(-spread, spread);
        this.particles.push(new Particle(x, y, color, Utils.rand(2,5), a, 0.3, Utils.rand(1,3)));
    }

    update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.update(dt);
            if (p.life <= 0) this.particles.splice(i, 1);
        }
    }

    draw(ctx) {
        this.particles.forEach(p => p.draw(ctx));
    }
}

/**
 * GAME ENTITIES
 */
class Entity {
    constructor(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.markedForDeletion = false;
        this.angle = 0;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        this.drawBody(ctx);
        ctx.restore();
    }
    
    drawBody(ctx) {
        // Override
    }
}

class Projectile extends Entity {
    constructor(x, y, angle, speed, damage, owner, isHoming = false) {
        super(x, y, 4, owner === 'player' ? '#00f3ff' : '#ff3333');
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.speed = speed;
        this.damage = damage;
        this.owner = owner;
        this.life = 2.0; // Seconds
        this.isHoming = isHoming;
    }

    update(dt, targets) {
        if (this.isHoming && targets && targets.length > 0) {
            // Find closest target
            let closest = null;
            let minDist = Infinity;
            targets.forEach(t => {
                const d = Utils.dist(this.x, this.y, t.x, t.y);
                if (d < minDist) { minDist = d; closest = t; }
            });

            if (closest) {
                const targetAngle = Math.atan2(closest.y - this.y, closest.x - this.x);
                // Simple steering
                const currentAngle = Math.atan2(this.vy, this.vx);
                let diff = targetAngle - currentAngle;
                // Normalize angle
                while (diff < -Math.PI) diff += Math.PI*2;
                while (diff > Math.PI) diff -= Math.PI*2;
                
                const turnRate = 4 * dt;
                const newAngle = currentAngle + Utils.clamp(diff, -turnRate, turnRate);
                
                this.vx = Math.cos(newAngle) * this.speed;
                this.vy = Math.sin(newAngle) * this.speed;
            }
        }

        this.x += this.vx * dt * 60;
        this.y += this.vy * dt * 60;
        this.life -= dt;
        if (this.life <= 0) this.markedForDeletion = true;

        // Trail effect
        if (Math.random() > 0.5) {
            Game.particles.particles.push(new Particle(this.x, this.y, this.color, 0, 0, 0.2, 2));
        }
    }

    drawBody(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
    }
}

class Player extends Entity {
    constructor() {
        super(window.innerWidth / 2, window.innerHeight / 2, 12, '#00f3ff');
        this.speed = 5;
        this.maxHp = 100;
        this.hp = this.maxHp;
        this.vx = 0;
        this.vy = 0;
        this.friction = 0.92;
        this.acceleration = 0.8;
        
        // Weapon stats
        this.fireRate = 0.15; // Delay between shots
        this.lastShot = 0;
        this.damage = 10;
        this.multishot = 1;
        this.homingMissiles = false;
        
        // Overdrive
        this.overdrive = 0;
        this.maxOverdrive = 100;
        this.overdriveActive = false;

        // Input state
        this.keys = {};
        this.mouse = { x: 0, y: 0, down: false };
    }

    update(dt) {
        // Movement Physics
        if (this.keys['w'] || this.keys['arrowup']) this.vy -= this.acceleration;
        if (this.keys['s'] || this.keys['arrowdown']) this.vy += this.acceleration;
        if (this.keys['a'] || this.keys['arrowleft']) this.vx -= this.acceleration;
        if (this.keys['d'] || this.keys['arrowright']) this.vx += this.acceleration;

        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.friction;
        this.vy *= this.friction;

        // Screen Bounds
        this.x = Utils.clamp(this.x, this.radius, Game.width - this.radius);
        this.y = Utils.clamp(this.y, this.radius, Game.height - this.radius);

        // Rotation
        this.angle = Math.atan2(this.mouse.y - this.y, this.mouse.x - this.x);

        // Shooting
        this.lastShot -= dt;
        if (this.mouse.down && this.lastShot <= 0) {
            this.shoot();
            this.lastShot = this.fireRate;
        }

        // Thruster particles
        if (Math.abs(this.vx) > 1 || Math.abs(this.vy) > 1) {
            Game.particles.createThrust(this.x, this.y, Math.atan2(this.vy, this.vx), '#00f3ff');
        }

        // Overdrive charging
        this.overdrive = Math.min(this.overdrive + dt * 2, this.maxOverdrive);
        
        // Activate Overdrive input
        if (this.keys[' ']) {
            this.triggerOverdrive();
        }
    }

    shoot() {
        Game.audio.shoot();
        const spread = 0.1;
        
        // Main Cannon
        for(let i=0; i<this.multishot; i++) {
            const offset = (i - (this.multishot-1)/2) * spread;
            Game.projectiles.push(new Projectile(
                this.x + Math.cos(this.angle)*20,
                this.y + Math.sin(this.angle)*20,
                this.angle + offset,
                12,
                this.damage,
                'player'
            ));
        }

        // Homing Missiles (Upgrade)
        if (this.homingMissiles) {
            Game.projectiles.push(new Projectile(
                this.x, this.y, this.angle + Math.PI/2, 8, this.damage * 0.5, 'player', true
            ));
            Game.projectiles.push(new Projectile(
                this.x, this.y, this.angle - Math.PI/2, 8, this.damage * 0.5, 'player', true
            ));
        }
    }

    triggerOverdrive() {
        if (this.overdrive >= 100) {
            this.overdrive = 0;
            Game.audio.overdrive();
            Game.shake(20);
            
            // Clear all enemy bullets
            Game.projectiles = Game.projectiles.filter(p => p.owner === 'player');
            
            // Massive damage to all enemies
            Game.enemies.forEach(e => {
                e.takeDamage(100);
                Game.particles.createExplosion(e.x, e.y, '#ffff00', 5);
            });

            // Visual ring
            for(let i=0; i<36; i++) {
                const a = (i/36) * Math.PI * 2;
                Game.particles.particles.push(new Particle(this.x, this.y, '#ffff00', 10, a, 1, 5));
            }
        }
    }

    takeDamage(amount) {
        this.hp -= amount;
        Game.shake(5);
        Game.audio.playerHit();
        Game.particles.createExplosion(this.x, this.y, '#ff0000', 10);
        if (this.hp <= 0) {
            Game.gameOver();
        }
    }

    drawBody(ctx) {
        // Ship Body
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.fillStyle = '#000';
        
        ctx.beginPath();
        ctx.moveTo(15, 0);
        ctx.lineTo(-10, 10);
        ctx.lineTo(-5, 0);
        ctx.lineTo(-10, -10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Cockpit
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(0, 0, 3, 0, Math.PI*2);
        ctx.fill();

        // Engine glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
    }
}

class Enemy extends Entity {
    constructor(type) {
        // Spawn edges
        let x, y;
        if (Math.random() < 0.5) {
            x = Math.random() < 0.5 ? -50 : Game.width + 50;
            y = Math.random() * Game.height;
        } else {
            x = Math.random() * Game.width;
            y = Math.random() < 0.5 ? -50 : Game.height + 50;
        }

        super(x, y, 15, '#ff3333');
        this.type = type;
        this.hp = 20;
        this.scoreValue = 100;
        
        // Type stats
        if (type === 'basic') {
            this.speed = 2;
            this.color = '#ff3333';
        } else if (type === 'fast') {
            this.speed = 4.5;
            this.hp = 10;
            this.radius = 10;
            this.color = '#ff00ff';
            this.scoreValue = 150;
        } else if (type === 'tank') {
            this.speed = 1;
            this.hp = 80;
            this.radius = 25;
            this.color = '#00ff00';
            this.scoreValue = 300;
        }

        this.vx = 0;
        this.vy = 0;
    }

    update(dt, player) {
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        
        // Simple AI: Move to player
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;

        // Separation (boid-like) to prevent stacking
        Game.enemies.forEach(other => {
            if (other === this) return;
            const d = Utils.dist(this.x, this.y, other.x, other.y);
            if (d < this.radius + other.radius) {
                const a = Math.atan2(this.y - other.y, this.x - other.x);
                this.vx += Math.cos(a) * 0.5;
                this.vy += Math.sin(a) * 0.5;
            }
        });

        this.x += this.vx * dt * 60;
        this.y += this.vy * dt * 60;
        this.angle = angle;

        // Shoot logic for Tanks
        if (this.type === 'tank' && Math.random() < 0.01) {
            Game.projectiles.push(new Projectile(this.x, this.y, angle, 6, 10, 'enemy'));
        }
    }

    takeDamage(amount) {
        this.hp -= amount;
        Game.audio.enemyHit();
        if (this.hp <= 0) {
            this.die();
        } else {
            // Flash white
            this.hitFlash = 5;
        }
    }

    die() {
        this.markedForDeletion = true;
        Game.score += this.scoreValue;
        Game.credits += Math.floor(this.scoreValue / 10); // Currency
        Game.audio.explosion();
        Game.particles.createExplosion(this.x, this.y, this.color, 15);
        Game.showFloatingText(`+${this.scoreValue}`, this.x, this.y);
        
        // Heal chance
        if (Math.random() < 0.05) {
            Game.powerups.push(new Powerup(this.x, this.y));
        }
    }

    drawBody(ctx) {
        if (this.hitFlash > 0) {
            ctx.fillStyle = '#fff';
            this.hitFlash--;
        } else {
            ctx.fillStyle = 'black';
        }
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;

        ctx.beginPath();
        if (this.type === 'basic') {
            ctx.moveTo(10, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, -10);
        } else if (this.type === 'fast') {
            ctx.moveTo(10, 0);
            ctx.lineTo(-5, 5);
            ctx.lineTo(-5, -5);
        } else if (this.type === 'tank') {
            ctx.rect(-15, -15, 30, 30);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
}

class Powerup extends Entity {
    constructor(x, y) {
        super(x, y, 8, '#00ff00');
        this.life = 10; // Disappear after 10s
    }

    update(dt) {
        this.life -= dt;
        if (this.life <= 0) this.markedForDeletion = true;
        
        // Bobbing animation
        this.radius = 8 + Math.sin(Date.now() / 200) * 2;
    }

    drawBody(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(0, -5);
        ctx.lineTo(0, 5);
        ctx.moveTo(-5, 0);
        ctx.lineTo(5, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0,0, this.radius, 0, Math.PI*2);
        ctx.stroke();
    }
}

/**
 * SHOP SYSTEM
 */
const Upgrades = [
    { id: 'dmg', name: 'Plasma Boost', desc: 'Increase Damage (+5)', cost: 500, level: 0, max: 10, apply: (p) => p.damage += 5 },
    { id: 'rate', name: 'Rapid Fire', desc: 'Fire Rate (+15%)', cost: 800, level: 0, max: 5, apply: (p) => p.fireRate *= 0.85 },
    { id: 'multi', name: 'Split Shot', desc: 'Add Projectile', cost: 2000, level: 0, max: 4, apply: (p) => p.multishot++ },
    { id: 'speed', name: 'Engine Tuner', desc: 'Ship Speed (+10%)', cost: 400, level: 0, max: 5, apply: (p) => p.speed *= 1.1 },
    { id: 'heal', name: 'Hull Repair', desc: 'Restore 50 HP', cost: 200, level: 0, max: 999, apply: (p) => p.hp = Math.min(p.hp + 50, p.maxHp) },
    { id: 'missile', name: 'Homing Pods', desc: 'Unlock Missiles', cost: 5000, level: 0, max: 1, apply: (p) => p.homingMissiles = true },
];

/**
 * MAIN GAME CONTROLLER
 */
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    width: window.innerWidth,
    height: window.innerHeight,
    
    // State
    isRunning: false,
    isPaused: false,
    score: 0,
    credits: 0,
    wave: 1,
    waveTimer: 0,
    
    // Entities
    player: null,
    enemies: [],
    projectiles: [],
    particles: null,
    powerups: [],
    
    // Systems
    audio: new AudioController(),
    lastTime: 0,
    shakeTime: 0,
    
    // Wave Config
    enemySpawnTimer: 0,
    spawnRate: 2.0,

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Input Listeners
        window.addEventListener('keydown', e => {
            if (e.key === 'Escape') this.toggleShop();
            if (this.player) this.player.keys[e.key.toLowerCase()] = true;
        });
        window.addEventListener('keyup', e => {
            if (this.player) this.player.keys[e.key.toLowerCase()] = false;
        });
        window.addEventListener('mousemove', e => {
            if (this.player) {
                const rect = this.canvas.getBoundingClientRect();
                this.player.mouse.x = e.clientX - rect.left;
                this.player.mouse.y = e.clientY - rect.top;
            }
        });
        window.addEventListener('mousedown', () => { if(this.player) this.player.mouse.down = true; });
        window.addEventListener('mouseup', () => { if(this.player) this.player.mouse.down = false; });
        
        this.particles = new ParticleSystem();
        
        // Pre-render shop
        this.renderShop();
        
        requestAnimationFrame(t => this.loop(t));
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    },

    start() {
        document.getElementById('main-menu').classList.remove('active');
        document.getElementById('game-over-menu').classList.remove('active');
        
        this.player = new Player();
        this.enemies = [];
        this.projectiles = [];
        this.powerups = [];
        this.score = 0;
        this.credits = 0;
        this.wave = 1;
        this.spawnRate = 2.0;
        this.isRunning = true;
        this.isPaused = false;
        this.lastTime = performance.now();
        
        // Reset upgrades for new game
        Upgrades.forEach(u => u.level = 0);
        this.renderShop();
    },

    restart() {
        this.start();
    },

    toggleShop() {
        if (!this.isRunning) return;
        this.isPaused = !this.isPaused;
        const menu = document.getElementById('shop-menu');
        if (this.isPaused) {
            menu.classList.add('active');
            this.renderShop();
        } else {
            menu.classList.remove('active');
            this.lastTime = performance.now(); // Reset delta to prevent jumps
        }
    },

    resume() {
        this.toggleShop();
    },

    gameOver() {
        this.isRunning = false;
        document.getElementById('game-over-menu').classList.add('active');
        document.getElementById('final-score').innerText = this.score;
        document.getElementById('final-wave').innerText = this.wave;
        this.audio.playTone(100, 'sawtooth', 1.0, 1.0, -50);
    },

    renderShop() {
        const grid = document.getElementById('shop-grid');
        grid.innerHTML = '';
        document.getElementById('shop-credits').innerText = this.credits;

        Upgrades.forEach(u => {
            const div = document.createElement('div');
            div.className = `shop-item ${ (this.credits < u.cost || u.level >= u.max) ? 'disabled' : ''}`;
            div.innerHTML = `
                <h3>${u.name}</h3>
                <p>${u.desc}</p>
                <div class="cost">${u.level >= u.max ? 'MAX' : u.cost + ' CR'}</div>
                <p style="color: #666">Lvl ${u.level}/${u.max}</p>
            `;
            div.onclick = () => this.buyUpgrade(u);
            grid.appendChild(div);
        });
    },

    buyUpgrade(u) {
        if (this.credits >= u.cost && u.level < u.max) {
            this.credits -= u.cost;
            u.level++;
            u.apply(this.player);
            // Increase cost
            u.cost = Math.floor(u.cost * 1.5);
            Game.audio.powerup();
            this.renderShop();
        }
    },

    spawnEnemy() {
        const r = Math.random();
        let type = 'basic';
        if (this.wave > 2 && r > 0.7) type = 'fast';
        if (this.wave > 4 && r > 0.9) type = 'tank';
        
        this.enemies.push(new Enemy(type));
    },

    showFloatingText(text, x, y) {
        const el = document.createElement('div');
        el.className = 'toast';
        el.innerText = text;
        el.style.position = 'absolute';
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.fontSize = '14px';
        el.style.padding = '2px 5px';
        el.style.pointerEvents = 'none';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    },

    shake(intensity) {
        this.shakeTime = intensity;
    },

    loop(timestamp) {
        requestAnimationFrame(t => this.loop(t));
        
        if (!this.isRunning || this.isPaused) return;

        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        // Logic
        this.player.update(dt);
        this.particles.update(dt);
        
        // Projectiles
        this.projectiles.forEach(p => p.update(dt, p.owner === 'player' ? this.enemies : [this.player]));
        this.projectiles = this.projectiles.filter(p => !p.markedForDeletion && 
            p.x > -50 && p.x < this.width + 50 && p.y > -50 && p.y < this.height + 50);

        // Enemies & Spawning
        this.enemySpawnTimer -= dt;
        if (this.enemySpawnTimer <= 0) {
            this.spawnEnemy();
            this.enemySpawnTimer = this.spawnRate;
        }

        // Wave Logic
        this.waveTimer += dt;
        if (this.waveTimer > 30) { // Every 30 seconds diff up
            this.wave++;
            this.waveTimer = 0;
            this.spawnRate = Math.max(0.2, this.spawnRate * 0.9);
            this.showFloatingText(`WAVE ${this.wave} INCOMING`, this.width/2, this.height/3);
            this.audio.playTone(300, 'sine', 1.0);
        }

        this.enemies.forEach(e => e.update(dt, this.player));
        this.enemies = this.enemies.filter(e => !e.markedForDeletion);
        
        this.powerups.forEach(p => p.update(dt));
        this.powerups = this.powerups.filter(p => !p.markedForDeletion);

        // Collision Detection
        // 1. Projectiles vs Entities
        this.projectiles.forEach(p => {
            if (p.owner === 'player') {
                this.enemies.forEach(e => {
                    if (Utils.checkCircleCol(p, e)) {
                        e.takeDamage(p.damage);
                        p.markedForDeletion = true;
                        this.particles.createExplosion(p.x, p.y, p.color, 3);
                    }
                });
            } else {
                if (Utils.checkCircleCol(p, this.player)) {
                    this.player.takeDamage(p.damage);
                    p.markedForDeletion = true;
                }
            }
        });

        // 2. Player vs Enemy (Crash)
        this.enemies.forEach(e => {
            if (Utils.checkCircleCol(this.player, e)) {
                this.player.takeDamage(10);
                e.takeDamage(100); // Destroy enemy on impact usually
                this.shake(10);
            }
        });

        // 3. Player vs Powerup
        this.powerups.forEach(p => {
            if (Utils.checkCircleCol(this.player, p)) {
                this.player.hp = Math.min(this.player.hp + 20, this.player.maxHp);
                p.markedForDeletion = true;
                this.audio.powerup();
                this.showFloatingText("REPAIR", this.player.x, this.player.y - 20);
            }
        });

        // Drawing
        // Screen Shake
        this.ctx.save();
        if (this.shakeTime > 0) {
            const mag = this.shakeTime;
            const dx = Utils.rand(-mag, mag);
            const dy = Utils.rand(-mag, mag);
            this.ctx.translate(dx, dy);
            this.shakeTime -= dt * 30; // decay
            if (this.shakeTime < 0) this.shakeTime = 0;
        }

        // Clear
        this.ctx.fillStyle = 'rgba(5, 5, 16, 0.4)'; // Trails effect
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        // Grid background
        this.drawGrid();

        this.particles.draw(this.ctx);
        this.powerups.forEach(p => p.draw(this.ctx));
        this.enemies.forEach(e => e.draw(this.ctx));
        this.player.draw(this.ctx);
        this.projectiles.forEach(p => p.draw(this.ctx));
        
        this.ctx.restore();

        // UI Updates
        document.getElementById('hud-score').innerText = this.score;
        document.getElementById('hud-wave').innerText = this.wave;
        document.getElementById('hud-hp').style.width = (this.player.hp / this.player.maxHp * 100) + '%';
        document.getElementById('hud-overdrive').style.width = this.player.overdrive + '%';
        document.getElementById('hud-fps').innerText = Math.round(1/dt);
    },

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)';
        this.ctx.lineWidth = 1;
        const gridSize = 50;
        const offsetX = -this.player.x * 0.1 % gridSize;
        const offsetY = -this.player.y * 0.1 % gridSize;
        
        this.ctx.beginPath();
        for(let x=offsetX; x<this.width; x+=gridSize) {
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.height);
        }
        for(let y=offsetY; y<this.height; y+=gridSize) {
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.width, y);
        }
        this.ctx.stroke();
    },
};

// Start
Game.init();

</script>
</body>
</html>
