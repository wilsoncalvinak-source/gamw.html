<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TERMINAL 9 // STALKER_DETECTED</title>
    <style>
        :root { --p-green: #00ff41; --p-red: #ff0000; --bg: #000; }
        body { background: var(--bg); color: var(--p-green); font-family: 'Courier New', monospace; margin: 0; overflow: hidden; height: 100vh; }
        
        #game-window { max-width: 900px; margin: auto; height: 100vh; display: flex; flex-direction: column; padding: 20px; position: relative; z-index: 5; }
        #output { flex: 1; overflow-y: auto; padding: 20px 0; font-size: 1.1rem; }
        .input-area { display: flex; border-top: 1px solid #1a1a1a; padding: 20px 0; }
        input { background: transparent; border: none; color: var(--p-green); font-family: inherit; font-size: 1.2rem; flex: 1; outline: none; }

        /* JUMPSCARE */
        #jumpscare { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: white; display: none; z-index: 100; 
            justify-content: center; align-items: center;
        }
        .face { font-size: 20rem; color: black; font-weight: bold; }

        /* STALKER EFFECTS */
        .proximity { color: var(--p-red); font-weight: bold; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        
        .glitch { animation: shake 0.1s infinite; color: var(--p-red); }
        @keyframes shake {
            0% { transform: translate(1px, 1px); }
            50% { transform: translate(-2px, -1px); }
            100% { transform: translate(1px, -2px); }
        }
        
        canvas { position: fixed; top: 0; left: 0; opacity: 0.08; pointer-events: none; }
    </style>
</head>
<body>
    <div id="jumpscare"><div class="face">†(X_X)†</div></div>
    <canvas id="staticCanvas"></canvas>

    <div id="game-window">
        <div style="display:flex; justify-content:space-between; border-bottom: 1px solid #333;">
            <span id="loc">UPLINKING...</span>
            <span id="san">SANITY: 100%</span>
        </div>
        <div id="output"></div>
        <div class="input-area">
            <span>>&nbsp;</span><input type="text" id="userInput" autofocus autocomplete="off">
        </div>
    </div>

<script>
const game = {
    sanity: 100,
    currentRoom: 'cryo',
    pursuerRoom: 'bridge', // The monster starts at the bridge
    inventory: [],
    moveCount: 0,
    isAlive: true,

    rooms: {
        'cryo': { name: "CRYO-STORAGE B", desc: "Empty pods. One is filled with a thick, red liquid.", exits: { north: 'hallway', east: 'morgue' } },
        'morgue': { name: "BIO-LAB", desc: "A cadaver lies on the table. It is missing its skin.", exits: { west: 'cryo', north: 'decon' } },
        'decon': { name: "DECONTAMINATION", desc: "The sprayers are leaking acid. The air is yellow.", exits: { south: 'morgue', west: 'hallway' } },
        'hallway': { name: "THE VEIN", desc: "The corridor pulses like a throat. It's wet.", exits: { south: 'cryo', north: 'bridge', east: 'decon', west: 'engine' } },
        'engine': { name: "ENGINE ROOM", desc: "The reactor core glows with an unholy light.", exits: { east: 'hallway' }, items: ['core_key'] },
        'bridge': { name: "COMMAND BRIDGE", desc: "The Captain's seat is empty. Blood is on the controls.", exits: { south: 'hallway' }, locked: true, key: 'core_key' }
    },

    init() {
        this.log("ENTITY TRACKING INITIALIZED...", "meta");
        this.updateRoom();
        this.drawStatic();
    },

    log(msg, type = "") {
        const out = document.getElementById('output');
        const p = document.createElement('p');
        p.innerHTML = msg;
        if(type) p.className = type;
        out.appendChild(p);
        out.scrollTop = out.scrollHeight;
    },

    triggerDeath() {
        this.isAlive = false;
        document.getElementById('jumpscare').style.display = 'flex';
        this.playScream(200, 0.8);
        setTimeout(() => {
            document.body.innerHTML = "<div style='background:red; color:black; height:100vh; display:flex; align-items:center; justify-content:center; font-family:serif;'><h1>YOU WERE CONSUMED</h1></div>";
        }, 1000);
    },

    playScream(freq, duration) {
        const audio = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audio.createOscillator();
        const gain = audio.createGain();
        osc.connect(gain); gain.connect(audio.destination);
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, audio.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40, audio.currentTime + duration);
        osc.start(); osc.stop(audio.currentTime + duration);
    },

    movePursuer() {
        const room = this.rooms[this.pursuerRoom];
        const possibleMoves = Object.values(room.exits);
        this.pursuerRoom = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
        
        // If monster enters your room
        if (this.pursuerRoom === this.currentRoom) {
            this.triggerDeath();
        }
    },

    checkProximity() {
        const room = this.rooms[this.currentRoom];
        const neighbors = Object.values(room.exits);
        if (neighbors.includes(this.pursuerRoom)) {
            this.log("!!! SYSTEM DETECTS MOVEMENT IN ADJACENT SECTOR !!!", "proximity");
            this.playScream(60, 0.2);
        }
    },

    handleCommand(input) {
        if (!this.isAlive) return;
        const val = input.toLowerCase().trim();
        
        if (['north', 'south', 'east', 'west'].includes(val)) {
            this.movePlayer(val);
        } else if (val.startsWith('take')) {
            this.takeItem(val.split(' ')[1]);
        } else {
            this.log("COMMAND UNRECOGNIZED.");
        }

        // Logic: Stalker moves every 2 actions
        this.moveCount++;
        if (this.moveCount % 2 === 0) {
            this.movePursuer();
        }
        this.checkProximity();
    },

    movePlayer(dir) {
        const room = this.rooms[this.currentRoom];
        if (room.exits[dir]) {
            const next = room.exits[dir];
            if (this.rooms[next].locked && !this.inventory.includes(this.rooms[next].key)) {
                this.log("DOOR LOCKED. ACCESS DENIED.", "glitch");
            } else {
                this.currentRoom = next;
                if (this.currentRoom === this.pursuerRoom) {
                    this.triggerDeath();
                } else {
                    this.updateRoom();
                }
            }
        } else {
            this.log("PATH BLOCKED.");
            this.playScream(120, 0.1); // Small "thud" noise
        }
    },

    takeItem(item) {
        const room = this.rooms[this.currentRoom];
        if (room.items && room.items.includes(item)) {
            this.inventory.push(item);
            room.items = room.items.filter(i => i !== item);
            this.log(`RECOVERED: ${item.toUpperCase()}`);
        } else {
            this.log("ITEM NOT FOUND.");
        }
    },

    updateRoom() {
        const room = this.rooms[this.currentRoom];
        this.log(`<br><b style="color:white; text-decoration:underline;">${room.name}</b>`);
        this.log(room.desc);
        document.getElementById('loc').innerText = room.name;
    },

    drawStatic() {
        const canvas = document.getElementById('staticCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        setInterval(() => {
            const idata = ctx.createImageData(canvas.width, canvas.height);
            for (let i = 0; i < idata.data.length; i += 4) {
                const v = Math.random() * 255;
                idata.data[i] = idata.data[i+1] = idata.data[i+2] = v;
                idata.data[i+3] = 255;
            }
            ctx.putImageData(idata, 0, 0);
        }, 60);
    }
};

document.getElementById('userInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        game.handleCommand(e.target.value);
        e.target.value = '';
    }
});

game.init();
</script>
</body>
</html>
